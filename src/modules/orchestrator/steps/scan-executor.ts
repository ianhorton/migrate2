/**
 * Initial Scan Step Executor
 * Discovers and classifies all Serverless resources
 */

import { BaseStepExecutor } from '../step-executor';
import {
  MigrationState,
  MigrationStep,
  Resource,
  ResourceInventory,
  CloudFormationTemplate
} from '../../../types';
import { Scanner } from '../../scanner';
import { Logger } from '../../../utils/logger';
import * as fs from 'fs/promises';
import * as path from 'path';

interface ScanResult {
  serverlessConfig: any;
  cloudFormationTemplate: CloudFormationTemplate;
  inventory: ResourceInventory;
  resourceCount: {
    total: number;
    explicit: number;
    abstracted: number;
    stateful: number;
    stateless: number;
  };
}

export class ScanExecutor extends BaseStepExecutor {
  constructor() {
    super(MigrationStep.INITIAL_SCAN);
  }

  protected validatePrerequisites(state: MigrationState): boolean {
    // Validate source directory exists
    const { sourceDir } = state.config;

    try {
      // Check if serverless.yml exists
      const serverlessPath = path.join(sourceDir, 'serverless.yml');
      return true; // Will be validated in executeStep
    } catch (error) {
      this.logger.error('Source directory validation failed', error);
      return false;
    }
  }

  protected async executeStep(state: MigrationState): Promise<ScanResult> {
    this.logger.info('Starting resource scan...');

    const { sourceDir, stage, region } = state.config;
    const scanner = new Scanner(sourceDir);

    // Step 1: Parse serverless.yml configuration
    this.logger.info('Parsing Serverless configuration...');
    const serverlessConfig = await scanner.parseServerlessConfig();

    // Step 2: Generate CloudFormation template
    this.logger.info(`Generating CloudFormation template for stage: ${stage}`);
    const cfTemplate = await scanner.generateCloudFormation(stage);

    // Save generated template for reference
    const templatePath = path.join(sourceDir, '.serverless', 'cloudformation-template-scan.json');
    await fs.mkdir(path.dirname(templatePath), { recursive: true });
    await fs.writeFile(templatePath, JSON.stringify(cfTemplate, null, 2));
    this.logger.info(`CloudFormation template saved to: ${templatePath}`);

    // Step 3: Discover all resources
    this.logger.info('Discovering resources from CloudFormation template...');
    const inventory = await scanner.discoverResources(cfTemplate);

    // Step 4: Calculate resource counts
    const resourceCount = {
      total: inventory.explicit.length + inventory.abstracted.length,
      explicit: inventory.explicit.length,
      abstracted: inventory.abstracted.length,
      stateful: inventory.stateful.length,
      stateless: inventory.stateless.length
    };

    // Log summary
    this.logger.info('Resource scan completed:');
    this.logger.info(`  Total resources: ${resourceCount.total}`);
    this.logger.info(`  Explicit (in serverless.yml): ${resourceCount.explicit}`);
    this.logger.info(`  Abstracted (generated by Serverless): ${resourceCount.abstracted}`);
    this.logger.info(`  Stateful (requires import): ${resourceCount.stateful}`);
    this.logger.info(`  Stateless (can recreate): ${resourceCount.stateless}`);

    // Step 5: Store inventory in state
    const result: ScanResult = {
      serverlessConfig,
      cloudFormationTemplate: cfTemplate,
      inventory,
      resourceCount
    };

    return result;
  }

  protected async executeRollback(state: MigrationState): Promise<void> {
    // No rollback needed for scan step - it's read-only
    this.logger.info('No rollback needed for scan step (read-only operation)');
  }

  protected async runValidationChecks(state: MigrationState) {
    const checks = [];

    // Check 1: Serverless config exists
    const serverlessPath = path.join(state.config.sourceDir, 'serverless.yml');
    try {
      await fs.access(serverlessPath);
      checks.push({
        name: 'serverless-config-exists',
        passed: true,
        message: 'Serverless configuration file found',
        severity: 'error' as const
      });
    } catch (error) {
      checks.push({
        name: 'serverless-config-exists',
        passed: false,
        message: `Serverless configuration not found at ${serverlessPath}`,
        severity: 'error' as const
      });
    }

    // Check 2: CloudFormation template generated
    const result = state.stepResults[MigrationStep.INITIAL_SCAN];
    if (result?.data?.cloudFormationTemplate) {
      const template = result.data.cloudFormationTemplate as CloudFormationTemplate;
      const hasResources = Object.keys(template.Resources || {}).length > 0;

      checks.push({
        name: 'cloudformation-generated',
        passed: hasResources,
        message: hasResources
          ? `CloudFormation template contains ${Object.keys(template.Resources).length} resources`
          : 'CloudFormation template is empty',
        severity: 'error' as const
      });
    } else {
      checks.push({
        name: 'cloudformation-generated',
        passed: false,
        message: 'CloudFormation template was not generated',
        severity: 'error' as const
      });
    }

    // Check 3: Resources discovered
    if (result?.data?.inventory) {
      const inventory = result.data.inventory as ResourceInventory;
      const totalResources = inventory.explicit.length + inventory.abstracted.length;

      checks.push({
        name: 'resources-discovered',
        passed: totalResources > 0,
        message: totalResources > 0
          ? `Discovered ${totalResources} resources`
          : 'No resources found in template',
        severity: 'error' as const
      });

      // Check 4: Stateful resources identified
      checks.push({
        name: 'stateful-resources-identified',
        passed: true,
        message: `Identified ${inventory.stateful.length} stateful resources that will require import`,
        severity: 'info' as const
      });
    }

    // Check 5: AWS credentials available
    if (process.env.AWS_PROFILE || (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY)) {
      checks.push({
        name: 'aws-credentials',
        passed: true,
        message: 'AWS credentials configured',
        severity: 'warning' as const
      });
    } else {
      checks.push({
        name: 'aws-credentials',
        passed: false,
        message: 'AWS credentials not found (required for later steps)',
        severity: 'warning' as const
      });
    }

    return checks;
  }
}
