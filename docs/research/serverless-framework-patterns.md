# Serverless Framework to CDK Migration: Research Findings

## Executive Summary

This document contains comprehensive research findings for building an automated Serverless Framework to AWS CDK migration tool. The research covers CloudFormation generation patterns, resource type mappings, comparison strategies, and common migration patterns.

**Research Date:** 2025-10-20
**Researcher:** Hive Mind Research Agent
**Swarm ID:** swarm-1760972243186-bfpe2o7mu

---

## Table of Contents

1. [Serverless Framework CloudFormation Generation](#1-serverless-framework-cloudformation-generation)
2. [CDK Resource Type Mappings](#2-cdk-resource-type-mappings)
3. [CloudFormation Template Comparison Strategies](#3-cloudformation-template-comparison-strategies)
4. [Common Migration Patterns](#4-common-migration-patterns)
5. [Migration Pitfalls and Edge Cases](#5-migration-pitfalls-and-edge-cases)
6. [Recommendations](#6-recommendations)

---

## 1. Serverless Framework CloudFormation Generation

### 1.1 How Serverless.yml Converts to CloudFormation

**Process Flow:**
```
serverless.yml
  → Variable Resolution
  → Plugin Processing
  → CloudFormation Template Generation
  → .serverless/cloudformation-template-update-stack.json
```

#### Key Generation Steps:

1. **Variable Resolution**
   - `${self:custom.var}` - Internal references
   - `${env:VAR}` - Environment variables
   - `${opt:option}` - CLI options
   - `${file(path)}` - External file references
   - `${cf:stack.output}` - CloudFormation outputs

2. **Plugin Processing**
   - Plugins can inject/modify CloudFormation resources
   - Common plugins: `serverless-plugin-typescript`, `serverless-offline`, `serverless-domain-manager`

3. **Template Generation**
   - Explicit resources from `resources.Resources`
   - Implicit resources (abstracted by Serverless)

### 1.2 Abstracted Resources Generated by Serverless

Serverless Framework automatically creates resources not explicitly defined in `serverless.yml`:

| Resource Type | Pattern | Purpose | Example Logical ID |
|--------------|---------|---------|-------------------|
| **CloudWatch LogGroups** | `/aws/lambda/{functionName}` | Lambda logs | `HelloLogGroup` |
| **IAM Roles** | `{FunctionName}IamRoleLambdaExecution` | Lambda execution | `HelloIamRoleLambdaExecution` |
| **Lambda Versions** | `{FunctionName}LambdaVersion{hash}` | Versioning | `HelloLambdaVersion1a2b3c4d` |
| **Lambda Permissions** | `{FunctionName}LambdaPermission{Trigger}` | Event permissions | `HelloLambdaPermissionApiGateway` |
| **API Gateway Resources** | Auto-generated | REST API structure | `ApiGatewayResourceUsers` |
| **API Gateway Methods** | Auto-generated | HTTP methods | `ApiGatewayMethodUsersPost` |
| **API Gateway Deployment** | `ApiGatewayDeployment{timestamp}` | API deployment | `ApiGatewayDeployment1234567890` |
| **S3 Bucket (artifacts)** | `ServerlessDeploymentBucket` | Deployment storage | `ServerlessDeploymentBucket` |

**Critical Finding:** Approximately 60-80% of resources in a Serverless CloudFormation stack are abstracted (not in serverless.yml).

### 1.3 Resource Naming Patterns

**Logical ID Conventions:**

```typescript
// Function Names
const functionLogicalId = pascalCase(functionKey);
// hello-world → HelloDashworldLambdaFunction

// LogGroup Names
const logGroupLogicalId = `${functionLogicalId}LogGroup`;
// HelloDashworldLogGroup

// IAM Role Names
const roleLogicalId = `${functionLogicalId}IamRoleLambdaExecution`;
// HelloDashworldIamRoleLambdaExecution

// Lambda Version
const versionLogicalId = `${functionLogicalId}LambdaVersion${hash}`;
// HelloDashworldLambdaVersion1a2b3c4d5e6f7g8h
```

**Physical ID Patterns:**

```typescript
// Stack name pattern
const stackName = `${service}-${stage}`;
// my-service-dev

// Function physical name
const functionName = `${stackName}-${functionKey}`;
// my-service-dev-hello-world

// LogGroup physical name
const logGroupName = `/aws/lambda/${functionName}`;
// /aws/lambda/my-service-dev-hello-world

// Role physical name
const roleName = `${stackName}-${region}-lambdaRole`;
// my-service-dev-us-east-1-lambdaRole
```

### 1.4 serverless.yml Property Mappings

**Common Properties and Their CloudFormation Equivalents:**

```yaml
# serverless.yml
functions:
  hello:
    handler: src/hello.handler
    runtime: nodejs18.x
    memorySize: 256
    timeout: 30
    environment:
      TABLE_NAME: ${self:custom.tableName}
    events:
      - http:
          path: /hello
          method: post
```

**Maps to CloudFormation:**

```json
{
  "HelloLambdaFunction": {
    "Type": "AWS::Lambda::Function",
    "Properties": {
      "FunctionName": "my-service-dev-hello",
      "Handler": "src/hello.handler",
      "Runtime": "nodejs18.x",
      "MemorySize": 256,
      "Timeout": 30,
      "Environment": {
        "Variables": {
          "TABLE_NAME": "my-table"
        }
      },
      "Role": { "Fn::GetAtt": ["HelloIamRoleLambdaExecution", "Arn"] }
    }
  },
  "HelloLogGroup": {
    "Type": "AWS::Logs::LogGroup",
    "Properties": {
      "LogGroupName": "/aws/lambda/my-service-dev-hello"
    }
  }
}
```

### 1.5 Custom Resources Section

Resources explicitly defined in `serverless.yml`:

```yaml
resources:
  Resources:
    UsersTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tableName}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
```

**These are preserved exactly as written** in the CloudFormation template.

---

## 2. CDK Resource Type Mappings

### 2.1 L1 vs L2 Constructs

**L1 Constructs (CloudFormation Resources):**
- Direct 1:1 mapping to CloudFormation
- Prefix: `Cfn` (e.g., `CfnTable`, `CfnBucket`)
- All properties exactly match CloudFormation
- No helper methods or abstractions

**L2 Constructs (Higher-level Constructs):**
- Simplified, opinionated interfaces
- Built-in best practices
- Helper methods and integrations
- May generate multiple CloudFormation resources

### 2.2 Complete Resource Type Mapping

| CloudFormation Type | L1 Construct | L2 Construct | Module | Notes |
|---------------------|-------------|--------------|--------|-------|
| **AWS::DynamoDB::Table** | `CfnTable` | `Table` | `aws-dynamodb` | L2 adds streams, GSI helpers |
| **AWS::S3::Bucket** | `CfnBucket` | `Bucket` | `aws-s3` | L2 adds encryption, versioning |
| **AWS::Logs::LogGroup** | `CfnLogGroup` | `LogGroup` | `aws-logs` | L2 adds retention helpers |
| **AWS::Lambda::Function** | `CfnFunction` | `Function` | `aws-lambda` | L2 adds Code abstraction |
| **AWS::IAM::Role** | `CfnRole` | `Role` | `aws-iam` | L2 adds grant methods |
| **AWS::IAM::Policy** | `CfnPolicy` | `Policy` | `aws-iam` | L2 adds statement helpers |
| **AWS::ApiGateway::RestApi** | `CfnRestApi` | `RestApi` | `aws-apigateway` | L2 adds resource/method helpers |
| **AWS::ApiGateway::Resource** | `CfnResource` | N/A | `aws-apigateway` | Created via RestApi.root |
| **AWS::ApiGateway::Method** | `CfnMethod` | N/A | `aws-apigateway` | Created via Resource.addMethod |
| **AWS::ApiGateway::Deployment** | `CfnDeployment` | `Deployment` | `aws-apigateway` | Auto-created by RestApi |
| **AWS::Lambda::Permission** | `CfnPermission` | N/A | `aws-lambda` | Auto-created by grants |
| **AWS::Lambda::Version** | `CfnVersion` | `Version` | `aws-lambda` | Created explicitly |

### 2.3 Import Requirements by Resource Type

**L2 Constructs - TypeScript:**

```typescript
import { Stack, StackProps, RemovalPolicy } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as logs from 'aws-cdk-lib/aws-logs';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
```

**L1 Constructs - Same imports, use Cfn prefix:**

```typescript
// L1 example
const table = new dynamodb.CfnTable(this, 'MyTable', {
  tableName: 'my-table',
  keySchema: [{ attributeName: 'id', keyType: 'HASH' }],
  attributeDefinitions: [{ attributeName: 'id', attributeType: 'S' }],
  billingMode: 'PAY_PER_REQUEST'
});

// L2 example
const table = new dynamodb.Table(this, 'MyTable', {
  tableName: 'my-table',
  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },
  billingMode: dynamodb.BillingMode.PAY_PER_REQUEST
});
```

### 2.4 Property Translation: CloudFormation → CDK

#### DynamoDB Table Example:

**CloudFormation:**
```json
{
  "Type": "AWS::DynamoDB::Table",
  "Properties": {
    "TableName": "users-table",
    "BillingMode": "PAY_PER_REQUEST",
    "AttributeDefinitions": [
      { "AttributeName": "id", "AttributeType": "S" },
      { "AttributeName": "email", "AttributeType": "S" }
    ],
    "KeySchema": [
      { "AttributeName": "id", "KeyType": "HASH" }
    ],
    "GlobalSecondaryIndexes": [{
      "IndexName": "email-index",
      "KeySchema": [{ "AttributeName": "email", "KeyType": "HASH" }],
      "Projection": { "ProjectionType": "ALL" }
    }],
    "StreamSpecification": {
      "StreamViewType": "NEW_AND_OLD_IMAGES"
    }
  }
}
```

**CDK L2 (TypeScript):**
```typescript
const table = new dynamodb.Table(this, 'UsersTable', {
  tableName: 'users-table',
  partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },
  billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
  stream: dynamodb.StreamViewType.NEW_AND_OLD_IMAGES,
  removalPolicy: RemovalPolicy.RETAIN,
});

table.addGlobalSecondaryIndex({
  indexName: 'email-index',
  partitionKey: { name: 'email', type: dynamodb.AttributeType.STRING },
  projectionType: dynamodb.ProjectionType.ALL,
});
```

**CDK L1 (TypeScript):**
```typescript
const table = new dynamodb.CfnTable(this, 'UsersTable', {
  tableName: 'users-table',
  billingMode: 'PAY_PER_REQUEST',
  attributeDefinitions: [
    { attributeName: 'id', attributeType: 'S' },
    { attributeName: 'email', attributeType: 'S' }
  ],
  keySchema: [
    { attributeName: 'id', keyType: 'HASH' }
  ],
  globalSecondaryIndexes: [{
    indexName: 'email-index',
    keySchema: [{ attributeName: 'email', keyType: 'HASH' }],
    projection: { projectionType: 'ALL' }
  }],
  streamSpecification: {
    streamViewType: 'NEW_AND_OLD_IMAGES'
  }
});
table.applyRemovalPolicy(RemovalPolicy.RETAIN);
```

**Key Differences:**
- L2 uses enums (`AttributeType.STRING` vs `'S'`)
- L2 has `partitionKey` shorthand vs `keySchema` + `attributeDefinitions`
- L2 uses helper methods like `addGlobalSecondaryIndex()`
- Both support `RemovalPolicy.RETAIN` for import safety

### 2.5 Migration Strategy: L1 vs L2

**Recommendation: Use L1 for Initial Migration**

**Rationale:**
1. **Exact Property Matching**: L1 constructs map 1:1 to CloudFormation
2. **Reduced Translation Errors**: No need to convert property formats
3. **Easier Comparison**: Can directly compare CloudFormation templates
4. **Safe Import**: Guaranteed to match existing resources

**Post-Migration Refactoring:**
- After successful import, refactor to L2 constructs
- Use CDK's built-in features and best practices
- Leverage helper methods and integrations

---

## 3. CloudFormation Template Comparison Strategies

### 3.1 Resource Matching Algorithm

**Primary Strategy: Physical ID Matching**

```typescript
interface ResourceMatch {
  resourceType: string;
  physicalIdProperty: string;
  slsLogicalId: string;
  cdkLogicalId: string;
  physicalId: string;
}

const physicalIdPropertyMap: Record<string, string> = {
  'AWS::DynamoDB::Table': 'TableName',
  'AWS::S3::Bucket': 'BucketName',
  'AWS::Logs::LogGroup': 'LogGroupName',
  'AWS::Lambda::Function': 'FunctionName',
  'AWS::IAM::Role': 'RoleName',
  'AWS::SNS::Topic': 'TopicName',
  'AWS::SQS::Queue': 'QueueName',
};

function matchResources(
  slsTemplate: CFTemplate,
  cdkTemplate: CFTemplate
): ResourceMatch[] {
  const matches: ResourceMatch[] = [];

  for (const [slsId, slsResource] of Object.entries(slsTemplate.Resources)) {
    const resourceType = slsResource.Type;
    const idProp = physicalIdPropertyMap[resourceType];

    if (!idProp) continue; // Skip resources without physical ID

    const slsPhysicalId = slsResource.Properties[idProp];

    for (const [cdkId, cdkResource] of Object.entries(cdkTemplate.Resources)) {
      if (cdkResource.Type !== resourceType) continue;

      const cdkPhysicalId = cdkResource.Properties[idProp];

      if (slsPhysicalId === cdkPhysicalId) {
        matches.push({
          resourceType,
          physicalIdProperty: idProp,
          slsLogicalId: slsId,
          cdkLogicalId: cdkId,
          physicalId: slsPhysicalId
        });
        break; // Found match, move to next resource
      }
    }
  }

  return matches;
}
```

**Fallback Strategies:**
1. **ARN Matching**: For resources referenced by ARN
2. **Tag Matching**: Use resource tags if physical names differ
3. **Attribute Matching**: Match by unique attribute combinations

### 3.2 Property Comparison Rules

**Severity Classification:**

```typescript
enum PropertySeverity {
  CRITICAL = 'CRITICAL',     // Must match exactly
  WARNING = 'WARNING',       // Should match, review required
  ACCEPTABLE = 'ACCEPTABLE', // CDK additions that are safe
  INFO = 'INFO'              // Informational differences
}

interface PropertyRule {
  criticalProperties: string[];      // Must match exactly
  warningProperties: string[];       // Review recommended
  acceptableAdditions: string[];     // Safe if only in CDK
  ignoredProperties: string[];       // Can differ, no impact
  computedProperties: string[];      // Generated, always different
}
```

**Complete Rule Set by Resource Type:**

```typescript
const comparisonRules: Record<string, PropertyRule> = {
  'AWS::DynamoDB::Table': {
    criticalProperties: [
      'TableName',
      'KeySchema',
      'AttributeDefinitions',
      'BillingMode'
    ],
    warningProperties: [
      'StreamSpecification',
      'GlobalSecondaryIndexes',
      'LocalSecondaryIndexes',
      'ProvisionedThroughput'
    ],
    acceptableAdditions: [
      'PointInTimeRecoverySpecification',
      'SSESpecification',
      'TimeToLiveSpecification',
      'Tags',
      'ContributorInsightsSpecification'
    ],
    ignoredProperties: [
      'UpdateReplacePolicy',
      'DeletionPolicy',
      'Metadata'
    ],
    computedProperties: []
  },

  'AWS::S3::Bucket': {
    criticalProperties: [
      'BucketName'
    ],
    warningProperties: [
      'VersioningConfiguration',
      'LifecycleConfiguration',
      'ReplicationConfiguration',
      'CorsConfiguration',
      'WebsiteConfiguration'
    ],
    acceptableAdditions: [
      'BucketEncryption',
      'PublicAccessBlockConfiguration',
      'Tags',
      'NotificationConfiguration',
      'IntelligentTieringConfigurations'
    ],
    ignoredProperties: [
      'UpdateReplacePolicy',
      'DeletionPolicy',
      'Metadata'
    ],
    computedProperties: [
      'Arn',
      'DomainName',
      'WebsiteURL'
    ]
  },

  'AWS::Logs::LogGroup': {
    criticalProperties: [
      'LogGroupName'
    ],
    warningProperties: [
      'KmsKeyId'
    ],
    acceptableAdditions: [
      'RetentionInDays',
      'Tags'
    ],
    ignoredProperties: [
      'UpdateReplacePolicy',
      'DeletionPolicy',
      'Metadata'
    ],
    computedProperties: [
      'Arn'
    ]
  },

  'AWS::Lambda::Function': {
    criticalProperties: [
      'FunctionName',
      'Runtime',
      'Handler'
    ],
    warningProperties: [
      'MemorySize',
      'Timeout',
      'Environment',
      'VpcConfig',
      'Layers',
      'ReservedConcurrentExecutions'
    ],
    acceptableAdditions: [
      'Tags',
      'TracingConfig',
      'DeadLetterConfig',
      'FileSystemConfigs'
    ],
    ignoredProperties: [
      'UpdateReplacePolicy',
      'DeletionPolicy',
      'Metadata',
      'Code' // Code changes handled separately
    ],
    computedProperties: [
      'Arn',
      'Version'
    ]
  },

  'AWS::IAM::Role': {
    criticalProperties: [
      'RoleName',
      'AssumeRolePolicyDocument'
    ],
    warningProperties: [
      'Policies',
      'ManagedPolicyArns',
      'MaxSessionDuration'
    ],
    acceptableAdditions: [
      'Tags',
      'PermissionsBoundary',
      'Description'
    ],
    ignoredProperties: [
      'UpdateReplacePolicy',
      'DeletionPolicy',
      'Metadata'
    ],
    computedProperties: [
      'Arn',
      'RoleId'
    ]
  }
};
```

### 3.3 Deep Property Comparison

**Nested Object Comparison:**

```typescript
function deepCompare(
  slsValue: any,
  cdkValue: any,
  path: string[] = []
): PropertyDifference[] {
  const differences: PropertyDifference[] = [];

  // Null/undefined handling
  if (slsValue === cdkValue) return [];
  if (slsValue == null && cdkValue == null) return [];

  // Type mismatch
  if (typeof slsValue !== typeof cdkValue) {
    return [{
      property: path.join('.'),
      slsValue,
      cdkValue,
      severity: PropertySeverity.CRITICAL,
      explanation: `Type mismatch: ${typeof slsValue} vs ${typeof cdkValue}`
    }];
  }

  // Array comparison
  if (Array.isArray(slsValue) && Array.isArray(cdkValue)) {
    if (slsValue.length !== cdkValue.length) {
      return [{
        property: path.join('.'),
        slsValue,
        cdkValue,
        severity: PropertySeverity.WARNING,
        explanation: `Array length differs: ${slsValue.length} vs ${cdkValue.length}`
      }];
    }

    // Compare array elements
    for (let i = 0; i < slsValue.length; i++) {
      differences.push(...deepCompare(
        slsValue[i],
        cdkValue[i],
        [...path, `[${i}]`]
      ));
    }

    return differences;
  }

  // Object comparison
  if (typeof slsValue === 'object' && slsValue !== null) {
    const allKeys = new Set([
      ...Object.keys(slsValue),
      ...Object.keys(cdkValue)
    ]);

    for (const key of allKeys) {
      const newPath = [...path, key];

      if (!(key in slsValue)) {
        differences.push({
          property: newPath.join('.'),
          slsValue: undefined,
          cdkValue: cdkValue[key],
          severity: PropertySeverity.INFO,
          explanation: 'Property only in CDK template'
        });
      } else if (!(key in cdkValue)) {
        differences.push({
          property: newPath.join('.'),
          slsValue: slsValue[key],
          cdkValue: undefined,
          severity: PropertySeverity.WARNING,
          explanation: 'Property only in Serverless template'
        });
      } else {
        differences.push(...deepCompare(
          slsValue[key],
          cdkValue[key],
          newPath
        ));
      }
    }

    return differences;
  }

  // Primitive value comparison
  if (slsValue !== cdkValue) {
    return [{
      property: path.join('.'),
      slsValue,
      cdkValue,
      severity: PropertySeverity.WARNING,
      explanation: 'Value differs'
    }];
  }

  return [];
}
```

### 3.4 Difference Classification Logic

```typescript
function classifyDifference(
  property: string,
  slsValue: any,
  cdkValue: any,
  rules: PropertyRule
): PropertyDifference {
  const propertyBase = property.split('.')[0];

  // Critical property mismatch
  if (rules.criticalProperties.includes(propertyBase)) {
    return {
      property,
      slsValue,
      cdkValue,
      severity: PropertySeverity.CRITICAL,
      explanation: 'Critical property must match exactly for safe import',
      autoFixable: false
    };
  }

  // CDK added an acceptable property
  if (slsValue === undefined && rules.acceptableAdditions.includes(propertyBase)) {
    return {
      property,
      slsValue,
      cdkValue,
      severity: PropertySeverity.ACCEPTABLE,
      explanation: `CDK added ${propertyBase}. This is a safe enhancement.`,
      autoFixable: false
    };
  }

  // Ignored property (metadata, policies)
  if (rules.ignoredProperties.includes(propertyBase)) {
    return {
      property,
      slsValue,
      cdkValue,
      severity: PropertySeverity.INFO,
      explanation: 'Property difference has no impact on resource import',
      autoFixable: false
    };
  }

  // Computed property (always differs, expected)
  if (rules.computedProperties.includes(propertyBase)) {
    return {
      property,
      slsValue,
      cdkValue,
      severity: PropertySeverity.INFO,
      explanation: 'Computed property, expected to differ',
      autoFixable: false
    };
  }

  // Warning-level property
  if (rules.warningProperties.includes(propertyBase)) {
    return {
      property,
      slsValue,
      cdkValue,
      severity: PropertySeverity.WARNING,
      explanation: 'Property configuration differs. Review recommended before import.',
      autoFixable: false
    };
  }

  // Unknown property difference
  return {
    property,
    slsValue,
    cdkValue,
    severity: PropertySeverity.WARNING,
    explanation: 'Unknown property difference. Manual review strongly recommended.',
    autoFixable: false
  };
}
```

### 3.5 Import Readiness Validation

```typescript
interface ValidationResult {
  readyForImport: boolean;
  blockingIssues: string[];
  warnings: string[];
  acceptableDifferences: string[];
}

function validateForImport(
  comparison: ComparisonResult
): ValidationResult {
  const result: ValidationResult = {
    readyForImport: true,
    blockingIssues: [],
    warnings: [],
    acceptableDifferences: []
  };

  for (const diff of comparison.differences) {
    switch (diff.severity) {
      case PropertySeverity.CRITICAL:
        result.readyForImport = false;
        result.blockingIssues.push(
          `${diff.property}: ${diff.explanation}`
        );
        break;

      case PropertySeverity.WARNING:
        result.warnings.push(
          `${diff.property}: ${diff.explanation}`
        );
        break;

      case PropertySeverity.ACCEPTABLE:
        result.acceptableDifferences.push(
          `${diff.property}: ${diff.explanation}`
        );
        break;

      case PropertySeverity.INFO:
        // No action needed
        break;
    }
  }

  return result;
}
```

---

## 4. Common Migration Patterns

### 4.1 DynamoDB Tables

**Serverless Framework:**
```yaml
resources:
  Resources:
    UsersTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:service}-users-${self:provider.stage}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
          - AttributeName: email
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        GlobalSecondaryIndexes:
          - IndexName: email-index
            KeySchema:
              - AttributeName: email
                KeyType: HASH
            Projection:
              ProjectionType: ALL
        StreamSpecification:
          StreamViewType: NEW_AND_OLD_IMAGES
```

**CDK Equivalent (L1):**
```typescript
const usersTable = new dynamodb.CfnTable(this, 'UsersTable', {
  tableName: `${serviceName}-users-${stage}`,
  billingMode: 'PAY_PER_REQUEST',
  attributeDefinitions: [
    { attributeName: 'id', attributeType: 'S' },
    { attributeName: 'email', attributeType: 'S' }
  ],
  keySchema: [
    { attributeName: 'id', keyType: 'HASH' }
  ],
  globalSecondaryIndexes: [{
    indexName: 'email-index',
    keySchema: [{ attributeName: 'email', keyType: 'HASH' }],
    projection: { projectionType: 'ALL' }
  }],
  streamSpecification: {
    streamViewType: 'NEW_AND_OLD_IMAGES'
  }
});

// Critical for import!
usersTable.applyRemovalPolicy(RemovalPolicy.RETAIN);
```

**Migration Checklist:**
- ✅ Table name matches exactly
- ✅ Key schema identical
- ✅ Attribute definitions match
- ✅ GSI configuration identical
- ✅ Stream specification matches
- ✅ Billing mode preserved
- ✅ RemovalPolicy set to RETAIN

### 4.2 S3 Buckets

**Serverless Framework:**
```yaml
resources:
  Resources:
    DataBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:custom.bucketName}
        VersioningConfiguration:
          Status: Enabled
        LifecycleConfiguration:
          Rules:
            - Id: DeleteOldVersions
              Status: Enabled
              NoncurrentVersionExpirationInDays: 30
        PublicAccessBlockConfiguration:
          BlockPublicAcls: true
          BlockPublicPolicy: true
          IgnorePublicAcls: true
          RestrictPublicBuckets: true
```

**CDK Equivalent (L1):**
```typescript
const dataBucket = new s3.CfnBucket(this, 'DataBucket', {
  bucketName: bucketName,
  versioningConfiguration: {
    status: 'Enabled'
  },
  lifecycleConfiguration: {
    rules: [{
      id: 'DeleteOldVersions',
      status: 'Enabled',
      noncurrentVersionExpirationInDays: 30
    }]
  },
  publicAccessBlockConfiguration: {
    blockPublicAcls: true,
    blockPublicPolicy: true,
    ignorePublicAcls: true,
    restrictPublicBuckets: true
  }
});

dataBucket.applyRemovalPolicy(RemovalPolicy.RETAIN);
```

**Migration Checklist:**
- ✅ Bucket name matches exactly
- ✅ Versioning configuration preserved
- ✅ Lifecycle rules identical
- ✅ Public access block settings match
- ✅ Encryption settings preserved (if any)
- ✅ CORS configuration preserved (if any)
- ✅ RemovalPolicy set to RETAIN

### 4.3 CloudWatch LogGroups

**Serverless Framework (Implicit):**
Serverless creates LogGroups automatically:
```yaml
functions:
  hello:
    handler: src/hello.handler
    # LogGroup created automatically
```

**Generated CloudFormation:**
```json
{
  "HelloLogGroup": {
    "Type": "AWS::Logs::LogGroup",
    "Properties": {
      "LogGroupName": "/aws/lambda/my-service-dev-hello"
    }
  }
}
```

**CDK Equivalent:**
```typescript
const helloLogGroup = new logs.CfnLogGroup(this, 'HelloLogGroup', {
  logGroupName: '/aws/lambda/my-service-dev-hello',
  retentionInDays: 7 // CDK often adds this
});

helloLogGroup.applyRemovalPolicy(RemovalPolicy.RETAIN);
```

**Migration Notes:**
- LogGroups are **stateful** (contain logs)
- Must be imported, not recreated
- Retention policy addition is **ACCEPTABLE** (won't cause drift)
- Physical name must match exactly

### 4.4 Lambda Functions

**Strategy: CREATE NEW, DO NOT IMPORT**

Lambda functions should be **recreated** with new names for parallel deployment:

**Serverless:**
```yaml
functions:
  api:
    handler: src/api.handler
    name: ${self:service}-${self:provider.stage}-api
    runtime: nodejs18.x
    memorySize: 256
    timeout: 30
    environment:
      TABLE_NAME: !Ref UsersTable
```

**CDK:**
```typescript
const apiFunction = new lambda.Function(this, 'ApiFunction', {
  functionName: `${serviceName}-${stage}-api-cdk`, // ← New name!
  runtime: lambda.Runtime.NODEJS_18_X,
  handler: 'src/api.handler',
  code: lambda.Code.fromAsset('dist'),
  memorySize: 256,
  timeout: Duration.seconds(30),
  environment: {
    TABLE_NAME: usersTable.ref
  },
  logGroup: helloLogGroup // Reference imported LogGroup
});

// Grant permissions
usersTable.grantReadWriteData(apiFunction);
```

**Why Create New Lambda Functions:**
1. **Code Changes**: Lambda code bundles likely differ
2. **Parallel Deployment**: Test CDK version alongside Serverless
3. **Rollback Safety**: Keep old function as fallback
4. **Minimal Downtime**: Switch traffic after verification

**Migration Process:**
1. Create new Lambda with `-cdk` suffix
2. Deploy and test
3. Update API Gateway/EventBridge to use new function
4. Monitor and verify
5. Delete old function when confident

### 4.5 IAM Roles

**Strategy: CREATE NEW**

IAM Roles should be recreated, not imported:

**Reasons:**
1. **Policy Differences**: CDK generates different inline policies
2. **Trust Relationships**: May differ in formatting
3. **Non-Critical**: Roles are stateless, safe to recreate
4. **Best Practices**: CDK applies security best practices

**Serverless (Implicit):**
```yaml
functions:
  api:
    handler: src/api.handler
    iamRoleStatements:
      - Effect: Allow
        Action:
          - dynamodb:PutItem
          - dynamodb:GetItem
        Resource: !GetAtt UsersTable.Arn
```

**CDK:**
```typescript
const apiRole = new iam.Role(this, 'ApiRole', {
  assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
  managedPolicies: [
    iam.ManagedPolicy.fromAwsManagedPolicyName(
      'service-role/AWSLambdaBasicExecutionRole'
    )
  ]
});

// Grant specific permissions
usersTable.grantReadWriteData(apiRole);

const apiFunction = new lambda.Function(this, 'ApiFunction', {
  // ...
  role: apiRole
});
```

**Migration Note:** Let CDK create new roles with proper permissions.

### 4.6 API Gateway

**Strategy: CREATE NEW**

API Gateway resources should be recreated:

**Reasons:**
1. **Different Structure**: Serverless creates different resource tree
2. **Deployment Changes**: Deployment IDs will differ
3. **Integration Updates**: Need to point to new Lambda functions
4. **Testing**: Can test new API alongside old one

**Serverless:**
```yaml
functions:
  getUser:
    handler: src/users/get.handler
    events:
      - http:
          path: /users/{id}
          method: get
```

**CDK:**
```typescript
const api = new apigateway.RestApi(this, 'ApiGateway', {
  restApiName: `${serviceName}-${stage}-api`,
  deployOptions: {
    stageName: stage
  }
});

const usersResource = api.root.addResource('users');
const userResource = usersResource.addResource('{id}');

userResource.addMethod('GET', new apigateway.LambdaIntegration(getUserFunction));
```

**Migration Process:**
1. Create new API Gateway in CDK
2. Deploy and test
3. Update DNS/custom domain to point to new API
4. Monitor traffic
5. Delete old API when confident

---

## 5. Migration Pitfalls and Edge Cases

### 5.1 Common Pitfalls

#### 1. **Forgetting to Set RemovalPolicy**

**Problem:**
```typescript
// ❌ WRONG - Will delete resource on stack deletion!
const table = new dynamodb.CfnTable(this, 'UsersTable', {
  tableName: 'users-table',
  // ... properties
});
```

**Solution:**
```typescript
// ✅ CORRECT - Protects resource
const table = new dynamodb.CfnTable(this, 'UsersTable', {
  tableName: 'users-table',
  // ... properties
});
table.applyRemovalPolicy(RemovalPolicy.RETAIN);
```

**Impact:** Without `RemovalPolicy.RETAIN`, deleting the CDK stack will delete the resource even after import.

#### 2. **Logical ID Mismatches**

**Problem:**
CDK generates logical IDs with hash suffixes:
```
Serverless: UsersTable
CDK:        UsersTable4F8E1A2B
```

**Impact:** Template comparison must match by physical ID, not logical ID.

**Solution:** Always use physical ID (TableName, BucketName) for matching.

#### 3. **Property Case Sensitivity**

**CloudFormation properties are case-sensitive:**
```json
// ❌ WRONG
{ "tableName": "users" }

// ✅ CORRECT
{ "TableName": "users" }
```

**CDK TypeScript:**
```typescript
// CDK uses camelCase in constructor
new CfnTable(this, 'Table', {
  tableName: 'users',  // ✅ camelCase
  keySchema: [...],    // ✅ camelCase
});

// But generates PascalCase in CloudFormation
// { "TableName": "users", "KeySchema": [...] }
```

#### 4. **Serverless Variable Resolution**

**Problem:**
Variables in serverless.yml must be resolved before comparison:
```yaml
custom:
  tableName: ${self:service}-${self:provider.stage}-users

resources:
  Resources:
    UsersTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tableName}
```

**Solution:** Always use the **generated CloudFormation template** from `.serverless/` directory, which has variables already resolved.

#### 5. **CDK Adding Default Properties**

**Problem:**
CDK often adds sensible defaults:
```typescript
// Your code
new logs.LogGroup(this, 'LogGroup', {
  logGroupName: '/aws/lambda/my-function'
});

// Generated CloudFormation
{
  "Type": "AWS::Logs::LogGroup",
  "Properties": {
    "LogGroupName": "/aws/lambda/my-function",
    "RetentionInDays": 7  // ← CDK added this!
  }
}
```

**Impact:** May cause comparison warnings

**Solution:** Classify as ACCEPTABLE if property is additive and non-destructive

#### 6. **Import Requires Exact Match**

**Critical:** `cdk import` requires **exact property match** for critical properties.

**If mismatch occurs:**
```
Error: Resource properties do not match existing resource
  Expected: { TableName: "users", KeySchema: [...] }
  Actual:   { TableName: "users-dev", KeySchema: [...] }
```

**Solution:** Fix CDK code to match exactly, then re-synth and re-compare.

### 5.2 Edge Cases

#### 1. **Lambda Versions**

**Problem:**
Serverless creates versioned Lambda functions:
```json
{
  "HelloLambdaVersionAbC123": {
    "Type": "AWS::Lambda::Version",
    "Properties": {
      "FunctionName": { "Ref": "HelloLambdaFunction" }
    }
  }
}
```

**Solution:** **Skip Lambda::Version** resources during import. They're tied to specific code and will be recreated naturally.

#### 2. **API Gateway Deployments**

**Problem:**
API Gateway deployments have timestamp-based logical IDs:
```json
{
  "ApiGatewayDeployment1234567890": {
    "Type": "AWS::ApiGateway::Deployment",
    "Properties": {
      "RestApiId": { "Ref": "ApiGatewayRestApi" }
    }
  }
}
```

**Solution:** **Recreate API Gateway** in CDK. Do not import deployments.

#### 3. **Circular Dependencies**

**Problem:**
Resources with circular references:
```yaml
ResourceA:
  Properties:
    DependsOn: ResourceB

ResourceB:
  Properties:
    DependsOn: ResourceA
```

**Solution:** Identify and break circular dependencies before migration. Use `DependsOn` explicitly if needed.

#### 4. **Custom Resources (Lambda-backed)**

**Problem:**
Custom resources backed by Lambda:
```yaml
resources:
  Resources:
    CustomResource:
      Type: Custom::MyCustomResource
      Properties:
        ServiceToken: !GetAtt CustomResourceFunction.Arn
```

**Solution:**
1. Migrate the Lambda function backing the custom resource
2. Update ServiceToken to new Lambda ARN
3. Test custom resource behavior before full migration

#### 5. **Stack Outputs Referenced by Other Stacks**

**Problem:**
Other stacks import outputs from this stack:
```yaml
Outputs:
  UsersTableName:
    Value: !Ref UsersTable
    Export:
      Name: ${self:service}-users-table
```

**Solution:**
1. Keep outputs in CDK stack with same export names
2. Ensure dependent stacks continue to work
3. Coordinate migration of dependent stacks

```typescript
new CfnOutput(this, 'UsersTableName', {
  value: usersTable.ref,
  exportName: `${serviceName}-users-table`
});
```

#### 6. **DynamoDB Table with Replicas (Global Tables)**

**Problem:**
Global tables have complex replication configuration:
```yaml
UsersTable:
  Type: AWS::DynamoDB::Table
  Properties:
    TableName: users-global
    Replicas:
      - Region: us-east-1
      - Region: eu-west-1
```

**Solution:** Global tables require special handling:
1. Document all replica regions
2. Ensure CDK includes all replicas
3. Test replication after import
4. Monitor replica lag

#### 7. **Resources Created Outside CloudFormation**

**Problem:**
Some resources exist in AWS but not in CloudFormation (created manually or by other tools).

**Solution:**
1. Identify orphaned resources
2. Decide: Import to CDK or leave unmanaged
3. Document any manual resources
4. Consider importing them for infrastructure-as-code completeness

---

## 6. Recommendations

### 6.1 Migration Tool Design Recommendations

1. **Use Physical ID Matching**
   - Primary strategy for resource matching
   - Fallback to ARN/tag matching for edge cases

2. **Implement Severity-Based Classification**
   - CRITICAL: Block import
   - WARNING: Require manual review
   - ACCEPTABLE: Allow with notification
   - INFO: Informational only

3. **Support Both L1 and L2 Generation**
   - **L1 for initial migration** (exact match)
   - **L2 for post-migration** (best practices)
   - Provide migration path from L1 → L2

4. **Comprehensive Validation**
   - Pre-import validation
   - Post-import verification
   - Drift detection
   - Resource existence checks

5. **State Management**
   - Track migration progress
   - Enable rollback
   - Support resume after failures
   - Audit trail for compliance

### 6.2 Resource-Specific Recommendations

**Always Import:**
- DynamoDB Tables (stateful)
- S3 Buckets (stateful)
- CloudWatch LogGroups (contain logs)
- RDS Databases (stateful)
- EFS File Systems (stateful)

**Always Recreate:**
- Lambda Functions (code changes, parallel deployment)
- API Gateway (different structure)
- IAM Roles (policy differences)
- Lambda Versions (tied to code)
- API Gateway Deployments (timestamp-based)

**Case-by-Case:**
- SNS Topics (import if subscribers external)
- SQS Queues (import if messages critical)
- EventBridge Rules (recreate unless complex)

### 6.3 Testing Strategy

1. **Sandbox Environment First**
   - Never test on production
   - Use dev/staging stacks
   - Validate entire process

2. **Comparison Report Review**
   - Manual review of ALL differences
   - Understand impact of each change
   - Fix critical mismatches before proceeding

3. **Dry Run Mode**
   - Test migration steps without execution
   - Validate CloudFormation templates
   - Check dependency graphs

4. **Incremental Migration**
   - Migrate one resource type at a time
   - Verify each step before proceeding
   - Easier to debug issues

5. **Parallel Deployment**
   - Keep Serverless and CDK running together
   - Gradual traffic migration
   - Quick rollback capability

### 6.4 Documentation Requirements

**Tool Should Generate:**
1. **Scan Report**
   - All discovered resources
   - Classification (import/recreate)
   - Dependency graph

2. **Comparison Report**
   - Resource matches
   - Property differences
   - Severity classifications
   - Recommendations

3. **Migration Plan**
   - Step-by-step execution plan
   - Risk assessment
   - Rollback procedures

4. **Post-Migration Report**
   - Resources successfully migrated
   - Resources recreated
   - Any warnings or issues
   - Next steps

### 6.5 Safety Mechanisms

1. **Automatic Backups**
   - CloudFormation templates
   - Migration state
   - Resource configurations

2. **Validation Gates**
   - Before each destructive operation
   - Require explicit approval
   - Display clear impact information

3. **Rollback Support**
   - Restore to any previous step
   - Automated rollback on critical failures
   - State recovery

4. **Verification Checks**
   - Resource existence
   - Stack drift detection
   - Property validation
   - Dependency integrity

---

## Appendix A: Resource Type Reference

### Complete Physical ID Property Map

```typescript
const physicalIdMap: Record<string, string> = {
  // Compute
  'AWS::Lambda::Function': 'FunctionName',
  'AWS::Lambda::LayerVersion': 'LayerVersionArn',

  // Storage
  'AWS::S3::Bucket': 'BucketName',
  'AWS::EFS::FileSystem': 'FileSystemId',

  // Database
  'AWS::DynamoDB::Table': 'TableName',
  'AWS::RDS::DBInstance': 'DBInstanceIdentifier',
  'AWS::RDS::DBCluster': 'DBClusterIdentifier',

  // Networking
  'AWS::EC2::VPC': 'VpcId',
  'AWS::EC2::Subnet': 'SubnetId',
  'AWS::EC2::SecurityGroup': 'GroupId',

  // Messaging
  'AWS::SNS::Topic': 'TopicName',
  'AWS::SQS::Queue': 'QueueName',

  // Monitoring
  'AWS::Logs::LogGroup': 'LogGroupName',
  'AWS::CloudWatch::Alarm': 'AlarmName',

  // IAM
  'AWS::IAM::Role': 'RoleName',
  'AWS::IAM::Policy': 'PolicyName',
  'AWS::IAM::User': 'UserName',

  // API Gateway
  'AWS::ApiGateway::RestApi': 'Name',
  'AWS::ApiGatewayV2::Api': 'Name',

  // EventBridge
  'AWS::Events::Rule': 'Name',

  // Step Functions
  'AWS::StepFunctions::StateMachine': 'StateMachineName',
};
```

### Import Recommendations by Type

| Resource Type | Recommendation | Reason |
|--------------|----------------|--------|
| DynamoDB Table | **IMPORT** | Stateful, contains data |
| S3 Bucket | **IMPORT** | Stateful, contains objects |
| CloudWatch LogGroup | **IMPORT** | Contains logs |
| Lambda Function | **RECREATE** | Code changes, parallel testing |
| IAM Role | **RECREATE** | Policy differences |
| API Gateway | **RECREATE** | Structure differences |
| SNS Topic | **CASE-BY-CASE** | Import if external subscribers |
| SQS Queue | **CASE-BY-CASE** | Import if messages critical |
| EventBridge Rule | **RECREATE** | Usually simple to recreate |
| Step Functions | **RECREATE** | Definition changes |

---

## Appendix B: Example Migration Scenarios

### Scenario 1: Simple Serverless Service

**Serverless.yml:**
```yaml
service: hello-world

provider:
  name: aws
  runtime: nodejs18.x
  stage: ${opt:stage, 'dev'}
  region: us-east-1

functions:
  hello:
    handler: src/hello.handler
    events:
      - http:
          path: /hello
          method: get

resources:
  Resources:
    GreetingsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: greetings-${self:provider.stage}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
```

**Generated CloudFormation (8 resources):**
1. `GreetingsTable` - DynamoDB Table (explicit)
2. `HelloLogGroup` - LogGroup (abstracted)
3. `HelloLambdaFunction` - Lambda (abstracted)
4. `HelloLambdaRole` - IAM Role (abstracted)
5. `HelloLambdaVersion` - Lambda Version (abstracted)
6. `ApiGatewayRestApi` - REST API (abstracted)
7. `ApiGatewayDeployment` - Deployment (abstracted)
8. `ServerlessDeploymentBucket` - S3 Bucket (abstracted)

**Migration Strategy:**
- **Import:** GreetingsTable, HelloLogGroup
- **Recreate:** Lambda, IAM Role, API Gateway
- **Skip:** Lambda Version, API Deployment, Deployment Bucket

### Scenario 2: Complex Multi-Function Service

**Serverless.yml:**
```yaml
service: user-management

provider:
  name: aws
  runtime: nodejs18.x
  stage: ${opt:stage, 'dev'}
  environment:
    USERS_TABLE: !Ref UsersTable

functions:
  createUser:
    handler: src/users/create.handler
    events:
      - http: { path: /users, method: post }

  getUser:
    handler: src/users/get.handler
    events:
      - http: { path: /users/{id}, method: get }

  updateUser:
    handler: src/users/update.handler
    events:
      - http: { path: /users/{id}, method: put }

resources:
  Resources:
    UsersTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: users-${self:provider.stage}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
          - AttributeName: email
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH
        GlobalSecondaryIndexes:
          - IndexName: email-index
            KeySchema:
              - AttributeName: email
                KeyType: HASH
            Projection:
              ProjectionType: ALL

    UsersBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: users-uploads-${self:provider.stage}
```

**Generated CloudFormation (20+ resources):**
- 2 explicit resources (UsersTable, UsersBucket)
- 3 LogGroups (one per function)
- 3 Lambda Functions
- 3 IAM Roles
- 3 Lambda Versions
- API Gateway resources (~8)
- Deployment bucket

**Migration Strategy:**
1. Import: UsersTable, UsersBucket, 3 LogGroups
2. Recreate: 3 Lambdas, 3 IAM Roles, API Gateway
3. Skip: Lambda Versions, Deployments

---

## Conclusion

This research provides a comprehensive foundation for building an automated Serverless Framework to AWS CDK migration tool. The key insights are:

1. **Physical ID matching** is the most reliable resource matching strategy
2. **Severity-based property comparison** enables safe automated decision-making
3. **L1 constructs** should be used initially for exact property matching
4. **Stateful resources** (DynamoDB, S3, LogGroups) must be imported
5. **Stateless resources** (Lambda, IAM, API Gateway) should be recreated
6. **Comprehensive validation** and safety mechanisms are essential

The tool should automate the tedious and error-prone aspects while keeping humans in the loop for critical decisions, ultimately reducing migration time from hours to minutes while significantly improving safety and reliability.

---

**Next Steps for Implementation:**
1. Build Scanner Module (resource discovery)
2. Build Comparator Module (template comparison)
3. Implement property comparison rules
4. Create CDK code generator (L1 constructs)
5. Build orchestration and state management
6. Add comprehensive testing and validation
